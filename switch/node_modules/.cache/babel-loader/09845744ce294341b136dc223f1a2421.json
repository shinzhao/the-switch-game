{"ast":null,"code":"/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nvar Class = require('../../utils/Class');\n\nvar DegToRad = require('../../math/DegToRad');\n\nvar DistanceBetween = require('../../math/distance/DistanceBetween');\n\nvar DistanceSquared = require('../../math/distance/DistanceSquared');\n\nvar Factory = require('./Factory');\n\nvar GetFastValue = require('../../utils/object/GetFastValue');\n\nvar Merge = require('../../utils/object/Merge');\n\nvar OverlapRect = require('./components/OverlapRect');\n\nvar PluginCache = require('../../plugins/PluginCache');\n\nvar SceneEvents = require('../../scene/events');\n\nvar Vector2 = require('../../math/Vector2');\n\nvar World = require('./World');\n/**\n * @classdesc\n * The Arcade Physics Plugin belongs to a Scene and sets up and manages the Scene's physics simulation.\n * It also holds some useful methods for moving and rotating Arcade Physics Bodies.\n *\n * You can access it from within a Scene using `this.physics`.\n * \n * Arcade Physics uses the Projection Method of collision resolution and separation. While it's fast and suitable\n * for 'arcade' style games it lacks stability when multiple objects are in close proximity or resting upon each other.\n * The separation that stops two objects penetrating may create a new penetration against a different object. If you\n * require a high level of stability please consider using an alternative physics system, such as Matter.js.\n *\n * @class ArcadePhysics\n * @memberof Phaser.Physics.Arcade\n * @constructor\n * @since 3.0.0\n *\n * @param {Phaser.Scene} scene - The Scene that this Plugin belongs to.\n */\n\n\nvar ArcadePhysics = new Class({\n  initialize: function ArcadePhysics(scene) {\n    /**\n     * The Scene that this Plugin belongs to.\n     *\n     * @name Phaser.Physics.Arcade.ArcadePhysics#scene\n     * @type {Phaser.Scene}\n     * @since 3.0.0\n     */\n    this.scene = scene;\n    /**\n     * The Scene's Systems.\n     *\n     * @name Phaser.Physics.Arcade.ArcadePhysics#systems\n     * @type {Phaser.Scenes.Systems}\n     * @since 3.0.0\n     */\n\n    this.systems = scene.sys;\n    /**\n     * A configuration object. Union of the `physics.arcade.*` properties of the GameConfig and SceneConfig objects.\n     *\n     * @name Phaser.Physics.Arcade.ArcadePhysics#config\n     * @type {object}\n     * @since 3.0.0\n     */\n\n    this.config = this.getConfig();\n    /**\n     * The physics simulation.\n     *\n     * @name Phaser.Physics.Arcade.ArcadePhysics#world\n     * @type {Phaser.Physics.Arcade.World}\n     * @since 3.0.0\n     */\n\n    this.world;\n    /**\n     * An object holding the Arcade Physics factory methods.\n     *\n     * @name Phaser.Physics.Arcade.ArcadePhysics#add\n     * @type {Phaser.Physics.Arcade.Factory}\n     * @since 3.0.0\n     */\n\n    this.add;\n    scene.sys.events.once(SceneEvents.BOOT, this.boot, this);\n    scene.sys.events.on(SceneEvents.START, this.start, this);\n  },\n\n  /**\n   * This method is called automatically, only once, when the Scene is first created.\n   * Do not invoke it directly.\n   *\n   * @method Phaser.Physics.Arcade.ArcadePhysics#boot\n   * @private\n   * @since 3.5.1\n   */\n  boot: function boot() {\n    this.world = new World(this.scene, this.config);\n    this.add = new Factory(this.world);\n    this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);\n  },\n\n  /**\n   * This method is called automatically by the Scene when it is starting up.\n   * It is responsible for creating local systems, properties and listening for Scene events.\n   * Do not invoke it directly.\n   *\n   * @method Phaser.Physics.Arcade.ArcadePhysics#start\n   * @private\n   * @since 3.5.0\n   */\n  start: function start() {\n    if (!this.world) {\n      this.world = new World(this.scene, this.config);\n      this.add = new Factory(this.world);\n    }\n\n    var eventEmitter = this.systems.events;\n    eventEmitter.on(SceneEvents.UPDATE, this.world.update, this.world);\n    eventEmitter.on(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);\n    eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);\n  },\n\n  /**\n   * Creates the physics configuration for the current Scene.\n   *\n   * @method Phaser.Physics.Arcade.ArcadePhysics#getConfig\n   * @since 3.0.0\n   *\n   * @return {object} The physics configuration.\n   */\n  getConfig: function getConfig() {\n    var gameConfig = this.systems.game.config.physics;\n    var sceneConfig = this.systems.settings.physics;\n    var config = Merge(GetFastValue(sceneConfig, 'arcade', {}), GetFastValue(gameConfig, 'arcade', {}));\n    return config;\n  },\n\n  /**\n   * Tests if Game Objects overlap. See {@link Phaser.Physics.Arcade.World#overlap}\n   *\n   * @method Phaser.Physics.Arcade.ArcadePhysics#overlap\n   * @since 3.0.0\n   *\n   * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object or array of objects to check.\n   * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} [object2] - The second object or array of objects to check, or `undefined`.\n   * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\n   * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they overlap. If this is set then `collideCallback` will only be called if this callback returns `true`.\n   * @param {*} [callbackContext] - The context in which to run the callbacks.\n   *\n   * @return {boolean} True if at least one Game Object overlaps another.\n   *\n   * @see Phaser.Physics.Arcade.World#overlap\n   */\n  overlap: function overlap(object1, object2, overlapCallback, processCallback, callbackContext) {\n    if (overlapCallback === undefined) {\n      overlapCallback = null;\n    }\n\n    if (processCallback === undefined) {\n      processCallback = null;\n    }\n\n    if (callbackContext === undefined) {\n      callbackContext = overlapCallback;\n    }\n\n    return this.world.collideObjects(object1, object2, overlapCallback, processCallback, callbackContext, true);\n  },\n\n  /**\n   * Performs a collision check and separation between the two physics enabled objects given, which can be single\n   * Game Objects, arrays of Game Objects, Physics Groups, arrays of Physics Groups or normal Groups.\n   *\n   * If you don't require separation then use {@link #overlap} instead.\n   *\n   * If two Groups or arrays are passed, each member of one will be tested against each member of the other.\n   *\n   * If **only** one Group is passed (as `object1`), each member of the Group will be collided against the other members.\n   * \n   * If **only** one Array is passed, the array is iterated and every element in it is tested against the others.\n   *\n   * Two callbacks can be provided. The `collideCallback` is invoked if a collision occurs and the two colliding\n   * objects are passed to it.\n   *\n   * Arcade Physics uses the Projection Method of collision resolution and separation. While it's fast and suitable\n   * for 'arcade' style games it lacks stability when multiple objects are in close proximity or resting upon each other.\n   * The separation that stops two objects penetrating may create a new penetration against a different object. If you\n   * require a high level of stability please consider using an alternative physics system, such as Matter.js.\n   *\n   * @method Phaser.Physics.Arcade.ArcadePhysics#collide\n   * @since 3.0.0\n   *\n   * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object or array of objects to check.\n   * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} [object2] - The second object or array of objects to check, or `undefined`.\n   * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\n   * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\n   * @param {*} [callbackContext] - The context in which to run the callbacks.\n   *\n   * @return {boolean} True if any overlapping Game Objects were separated, otherwise false.\n   *\n   * @see Phaser.Physics.Arcade.World#collide\n   */\n  collide: function collide(object1, object2, collideCallback, processCallback, callbackContext) {\n    if (collideCallback === undefined) {\n      collideCallback = null;\n    }\n\n    if (processCallback === undefined) {\n      processCallback = null;\n    }\n\n    if (callbackContext === undefined) {\n      callbackContext = collideCallback;\n    }\n\n    return this.world.collideObjects(object1, object2, collideCallback, processCallback, callbackContext, false);\n  },\n\n  /**\n   * This advanced method is specifically for testing for collision between a single Sprite and an array of Tile objects.\n   * \n   * You should generally use the `collide` method instead, with a Sprite vs. a Tilemap Layer, as that will perform\n   * tile filtering and culling for you, as well as handle the interesting face collision automatically.\n   * \n   * This method is offered for those who would like to check for collision with specific Tiles in a layer, without\n   * having to set any collision attributes on the tiles in question. This allows you to perform quick dynamic collisions\n   * on small sets of Tiles. As such, no culling or checks are made to the array of Tiles given to this method,\n   * you should filter them before passing them to this method.\n   * \n   * Important: Use of this method skips the `interesting faces` system that Tilemap Layers use. This means if you have\n   * say a row or column of tiles, and you jump into, or walk over them, it's possible to get stuck on the edges of the\n   * tiles as the interesting face calculations are skipped. However, for quick-fire small collision set tests on\n   * dynamic maps, this method can prove very useful.\n   *\n   * @method Phaser.Physics.Arcade.ArcadePhysics#collideTiles\n   * @fires Phaser.Physics.Arcade.Events#TILE_COLLIDE\n   * @since 3.17.0\n   *\n   * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\n   * @param {Phaser.Tilemaps.Tile[]} tiles - An array of Tiles to check for collision against.\n   * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\n   * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\n   * @param {any} [callbackContext] - The context in which to run the callbacks.\n   *\n   * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\n   */\n  collideTiles: function collideTiles(sprite, tiles, collideCallback, processCallback, callbackContext) {\n    return this.world.collideTiles(sprite, tiles, collideCallback, processCallback, callbackContext);\n  },\n\n  /**\n   * This advanced method is specifically for testing for overlaps between a single Sprite and an array of Tile objects.\n   * \n   * You should generally use the `overlap` method instead, with a Sprite vs. a Tilemap Layer, as that will perform\n   * tile filtering and culling for you, as well as handle the interesting face collision automatically.\n   * \n   * This method is offered for those who would like to check for overlaps with specific Tiles in a layer, without\n   * having to set any collision attributes on the tiles in question. This allows you to perform quick dynamic overlap\n   * tests on small sets of Tiles. As such, no culling or checks are made to the array of Tiles given to this method,\n   * you should filter them before passing them to this method.\n   *\n   * @method Phaser.Physics.Arcade.ArcadePhysics#overlapTiles\n   * @fires Phaser.Physics.Arcade.Events#TILE_OVERLAP\n   * @since 3.17.0\n   *\n   * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\n   * @param {Phaser.Tilemaps.Tile[]} tiles - An array of Tiles to check for collision against.\n   * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects overlap.\n   * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\n   * @param {any} [callbackContext] - The context in which to run the callbacks.\n   *\n   * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\n   */\n  overlapTiles: function overlapTiles(sprite, tiles, collideCallback, processCallback, callbackContext) {\n    return this.world.overlapTiles(sprite, tiles, collideCallback, processCallback, callbackContext);\n  },\n\n  /**\n   * Pauses the simulation.\n   *\n   * @method Phaser.Physics.Arcade.ArcadePhysics#pause\n   * @since 3.0.0\n   *\n   * @return {Phaser.Physics.Arcade.World} The simulation.\n   */\n  pause: function pause() {\n    return this.world.pause();\n  },\n\n  /**\n   * Resumes the simulation (if paused).\n   *\n   * @method Phaser.Physics.Arcade.ArcadePhysics#resume\n   * @since 3.0.0\n   *\n   * @return {Phaser.Physics.Arcade.World} The simulation.\n   */\n  resume: function resume() {\n    return this.world.resume();\n  },\n\n  /**\n   * Sets the acceleration.x/y property on the game object so it will move towards the x/y coordinates at the given rate (in pixels per second squared)\n   *\n   * You must give a maximum speed value, beyond which the game object won't go any faster.\n   *\n   * Note: The game object does not continuously track the target. If the target changes location during transit the game object will not modify its course.\n   * Note: The game object doesn't stop moving once it reaches the destination coordinates.\n   *\n   * @method Phaser.Physics.Arcade.ArcadePhysics#accelerateTo\n   * @since 3.0.0\n   *\n   * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\n   * @param {number} x - The x coordinate to accelerate towards.\n   * @param {number} y - The y coordinate to accelerate towards.\n   * @param {number} [speed=60] - The acceleration (change in speed) in pixels per second squared.\n   * @param {number} [xSpeedMax=500] - The maximum x velocity the game object can reach.\n   * @param {number} [ySpeedMax=500] - The maximum y velocity the game object can reach.\n   *\n   * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\n   */\n  accelerateTo: function accelerateTo(gameObject, x, y, speed, xSpeedMax, ySpeedMax) {\n    if (speed === undefined) {\n      speed = 60;\n    }\n\n    var angle = Math.atan2(y - gameObject.y, x - gameObject.x);\n    gameObject.body.acceleration.setToPolar(angle, speed);\n\n    if (xSpeedMax !== undefined && ySpeedMax !== undefined) {\n      gameObject.body.maxVelocity.set(xSpeedMax, ySpeedMax);\n    }\n\n    return angle;\n  },\n\n  /**\n   * Sets the acceleration.x/y property on the game object so it will move towards the x/y coordinates at the given rate (in pixels per second squared)\n   *\n   * You must give a maximum speed value, beyond which the game object won't go any faster.\n   *\n   * Note: The game object does not continuously track the target. If the target changes location during transit the game object will not modify its course.\n   * Note: The game object doesn't stop moving once it reaches the destination coordinates.\n   *\n   * @method Phaser.Physics.Arcade.ArcadePhysics#accelerateToObject\n   * @since 3.0.0\n   *\n   * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\n   * @param {Phaser.GameObjects.GameObject} destination - The Game Object to move towards. Can be any object but must have visible x/y properties.\n   * @param {number} [speed=60] - The acceleration (change in speed) in pixels per second squared.\n   * @param {number} [xSpeedMax=500] - The maximum x velocity the game object can reach.\n   * @param {number} [ySpeedMax=500] - The maximum y velocity the game object can reach.\n   *\n   * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\n   */\n  accelerateToObject: function accelerateToObject(gameObject, destination, speed, xSpeedMax, ySpeedMax) {\n    return this.accelerateTo(gameObject, destination.x, destination.y, speed, xSpeedMax, ySpeedMax);\n  },\n\n  /**\n   * Finds the Dynamic Body closest to a source point or object.\n   * \n   * If two or more bodies are the exact same distance from the source point, only the first body\n   * is returned.\n   *\n   * @method Phaser.Physics.Arcade.ArcadePhysics#closest\n   * @since 3.0.0\n   *\n   * @param {any} source - Any object with public `x` and `y` properties, such as a Game Object or Geometry object.\n   *\n   * @return {Phaser.Physics.Arcade.Body} The closest Dynamic Body to the given source point.\n   */\n  closest: function closest(source) {\n    var bodies = this.world.bodies;\n    var min = Number.MAX_VALUE;\n    var closest = null;\n    var x = source.x;\n    var y = source.y;\n    bodies.iterate(function (target) {\n      var distance = DistanceSquared(x, y, target.x, target.y);\n\n      if (distance < min) {\n        closest = target;\n        min = distance;\n      }\n    });\n    return closest;\n  },\n\n  /**\n   * Finds the Dynamic Body farthest from a source point or object.\n   * \n   * If two or more bodies are the exact same distance from the source point, only the first body\n   * is returned.\n   *\n   * @method Phaser.Physics.Arcade.ArcadePhysics#furthest\n   * @since 3.0.0\n   *\n   * @param {any} source - Any object with public `x` and `y` properties, such as a Game Object or Geometry object.\n   *\n   * @return {Phaser.Physics.Arcade.Body} The Dynamic Body furthest away from the given source point.\n   */\n  furthest: function furthest(source) {\n    var bodies = this.world.bodies;\n    var max = -1;\n    var farthest = null;\n    var x = source.x;\n    var y = source.y;\n    bodies.iterate(function (target) {\n      var distance = DistanceSquared(x, y, target.x, target.y);\n\n      if (distance > max) {\n        farthest = target;\n        max = distance;\n      }\n    });\n    return farthest;\n  },\n\n  /**\n   * Move the given display object towards the x/y coordinates at a steady velocity.\n   * If you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.\n   * Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.\n   * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\n   * Note: The display object doesn't stop moving once it reaches the destination coordinates.\n   * Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)\n   *\n   * @method Phaser.Physics.Arcade.ArcadePhysics#moveTo\n   * @since 3.0.0\n   *\n   * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\n   * @param {number} x - The x coordinate to move towards.\n   * @param {number} y - The y coordinate to move towards.\n   * @param {number} [speed=60] - The speed it will move, in pixels per second (default is 60 pixels/sec)\n   * @param {number} [maxTime=0] - Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.\n   *\n   * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\n   */\n  moveTo: function moveTo(gameObject, x, y, speed, maxTime) {\n    if (speed === undefined) {\n      speed = 60;\n    }\n\n    if (maxTime === undefined) {\n      maxTime = 0;\n    }\n\n    var angle = Math.atan2(y - gameObject.y, x - gameObject.x);\n\n    if (maxTime > 0) {\n      //  We know how many pixels we need to move, but how fast?\n      speed = DistanceBetween(gameObject.x, gameObject.y, x, y) / (maxTime / 1000);\n    }\n\n    gameObject.body.velocity.setToPolar(angle, speed);\n    return angle;\n  },\n\n  /**\n   * Move the given display object towards the destination object at a steady velocity.\n   * If you specify a maxTime then it will adjust the speed (overwriting what you set) so it arrives at the destination in that number of seconds.\n   * Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.\n   * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\n   * Note: The display object doesn't stop moving once it reaches the destination coordinates.\n   * Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)\n   *\n   * @method Phaser.Physics.Arcade.ArcadePhysics#moveToObject\n   * @since 3.0.0\n   *\n   * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\n   * @param {object} destination - Any object with public `x` and `y` properties, such as a Game Object or Geometry object.\n   * @param {number} [speed=60] - The speed it will move, in pixels per second (default is 60 pixels/sec)\n   * @param {number} [maxTime=0] - Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.\n   *\n   * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\n   */\n  moveToObject: function moveToObject(gameObject, destination, speed, maxTime) {\n    return this.moveTo(gameObject, destination.x, destination.y, speed, maxTime);\n  },\n\n  /**\n   * Given the angle (in degrees) and speed calculate the velocity and return it as a vector, or set it to the given vector object.\n   * One way to use this is: velocityFromAngle(angle, 200, sprite.body.velocity) which will set the values directly to the sprite's velocity and not create a new vector object.\n   *\n   * @method Phaser.Physics.Arcade.ArcadePhysics#velocityFromAngle\n   * @since 3.0.0\n   *\n   * @param {number} angle - The angle in degrees calculated in clockwise positive direction (down = 90 degrees positive, right = 0 degrees positive, up = 90 degrees negative)\n   * @param {number} [speed=60] - The speed it will move, in pixels per second squared.\n   * @param {Phaser.Math.Vector2} [vec2] - The Vector2 in which the x and y properties will be set to the calculated velocity.\n   *\n   * @return {Phaser.Math.Vector2} The Vector2 that stores the velocity.\n   */\n  velocityFromAngle: function velocityFromAngle(angle, speed, vec2) {\n    if (speed === undefined) {\n      speed = 60;\n    }\n\n    if (vec2 === undefined) {\n      vec2 = new Vector2();\n    }\n\n    return vec2.setToPolar(DegToRad(angle), speed);\n  },\n\n  /**\n   * Given the rotation (in radians) and speed calculate the velocity and return it as a vector, or set it to the given vector object.\n   * One way to use this is: velocityFromRotation(rotation, 200, sprite.body.velocity) which will set the values directly to the sprite's velocity and not create a new vector object.\n   *\n   * @method Phaser.Physics.Arcade.ArcadePhysics#velocityFromRotation\n   * @since 3.0.0\n   *\n   * @param {number} rotation - The angle in radians.\n   * @param {number} [speed=60] - The speed it will move, in pixels per second squared\n   * @param {Phaser.Math.Vector2} [vec2] - The Vector2 in which the x and y properties will be set to the calculated velocity.\n   *\n   * @return {Phaser.Math.Vector2} The Vector2 that stores the velocity.\n   */\n  velocityFromRotation: function velocityFromRotation(rotation, speed, vec2) {\n    if (speed === undefined) {\n      speed = 60;\n    }\n\n    if (vec2 === undefined) {\n      vec2 = new Vector2();\n    }\n\n    return vec2.setToPolar(rotation, speed);\n  },\n\n  /**\n   * This method will search the given rectangular area and return an array of all physics bodies that\n   * overlap with it. It can return either Dynamic, Static bodies or a mixture of both.\n   * \n   * A body only has to intersect with the search area to be considered, it doesn't have to be fully\n   * contained within it.\n   * \n   * If Arcade Physics is set to use the RTree (which it is by default) then the search for is extremely fast,\n   * otherwise the search is O(N) for Dynamic Bodies.\n   *\n   * @method Phaser.Physics.Arcade.ArcadePhysics#overlapRect\n   * @since 3.17.0\n   *\n   * @param {number} x - The top-left x coordinate of the area to search within.\n   * @param {number} y - The top-left y coordinate of the area to search within.\n   * @param {number} width - The width of the area to search within.\n   * @param {number} height - The height of the area to search within.\n   * @param {boolean} [includeDynamic=true] - Should the search include Dynamic Bodies?\n   * @param {boolean} [includeStatic=false] - Should the search include Static Bodies?\n   *\n   * @return {(Phaser.Physics.Arcade.Body[]|Phaser.Physics.Arcade.StaticBody[])} An array of bodies that overlap with the given area.\n   */\n  overlapRect: function overlapRect(x, y, width, height, includeDynamic, includeStatic) {\n    return OverlapRect(this.world, x, y, width, height, includeDynamic, includeStatic);\n  },\n\n  /**\n   * The Scene that owns this plugin is shutting down.\n   * We need to kill and reset all internal properties as well as stop listening to Scene events.\n   *\n   * @method Phaser.Physics.Arcade.ArcadePhysics#shutdown\n   * @since 3.0.0\n   */\n  shutdown: function shutdown() {\n    if (!this.world) {\n      //  Already destroyed\n      return;\n    }\n\n    var eventEmitter = this.systems.events;\n    eventEmitter.off(SceneEvents.UPDATE, this.world.update, this.world);\n    eventEmitter.off(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);\n    eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);\n    this.add.destroy();\n    this.world.destroy();\n    this.add = null;\n    this.world = null;\n  },\n\n  /**\n   * The Scene that owns this plugin is being destroyed.\n   * We need to shutdown and then kill off all external references.\n   *\n   * @method Phaser.Physics.Arcade.ArcadePhysics#destroy\n   * @since 3.0.0\n   */\n  destroy: function destroy() {\n    this.shutdown();\n    this.scene.sys.events.off(SceneEvents.START, this.start, this);\n    this.scene = null;\n    this.systems = null;\n  }\n});\nPluginCache.register('ArcadePhysics', ArcadePhysics, 'arcadePhysics');\nmodule.exports = ArcadePhysics;","map":null,"metadata":{},"sourceType":"script"}