{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nvar _this = this;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar apollo_cache_inmemory_1 = require(\"apollo-cache-inmemory\");\n\nvar offline_cache_1 = require(\"./cache/offline-cache\");\n\nvar apollo_utilities_1 = require(\"apollo-utilities\");\n\nvar utils_1 = require(\"./utils\");\n\nvar apollo_link_1 = require(\"apollo-link\");\n\nvar retry_link_1 = require(\"./link/retry-link\");\n\nvar graphql_1 = require(\"graphql\");\n\nvar offline_1 = require(\"./helpers/offline\");\n\nvar offline_link_1 = require(\"./link/offline-link\");\n\nvar subscription_handshake_link_1 = require(\"./link/subscription-handshake-link\");\n\nvar logger = utils_1.rootLogger.extend('deltasync');\nexports.DELTASYNC_KEY = 'deltaSync'; //#endregion\n//#region Constants\n\nvar actions = {\n  ENQUEUE: 'DELTASYNC_ENQUEUE_RECONNECT',\n  UPDATE_LASTSYNC: 'DELTASYNC_UPDATE_LASTSYNC'\n};\nvar DEFAULT_UPPER_BOUND_TIME_MS = 24 * 60 * 60 * 1000;\nvar MIN_UPPER_BOUND_TIME_MS = 2 * 1000;\nvar BUFFER_MILLISECONDS = 2000; //#endregion\n//#region helpers\n\nvar subscriptionMessagesProcessorCreator = function subscriptionMessagesProcessorCreator(proxy, updateFunction) {\n  var buffer = [];\n  var _ready = false;\n\n  var wrappedUpdateFunction = function wrappedUpdateFunction(proxy, record) {\n    return apollo_utilities_1.tryFunctionOrLogError(function () {\n      return updateFunction(proxy, record);\n    });\n  };\n\n  var processor = {\n    enqueue: function enqueue(record) {\n      if (_ready) {\n        wrappedUpdateFunction(proxy, record);\n        return;\n      }\n\n      buffer.push(record);\n    },\n    ready: function ready() {\n      if (_ready) {\n        return;\n      }\n\n      buffer.forEach(function (record) {\n        return wrappedUpdateFunction(proxy, record);\n      });\n      buffer = [];\n      _ready = true;\n    },\n    close: function close() {\n      buffer = [];\n      _ready = true;\n    }\n  };\n  return processor;\n};\n\nexports.hashForOptions = function (options) {\n  var _a = options.baseQuery,\n      _b = _a === void 0 ? {} : _a,\n      _c = _b.query,\n      baseQueryQuery = _c === void 0 ? null : _c,\n      _d = _b.variables,\n      baseQueryVariables = _d === void 0 ? {} : _d,\n      _e = options.subscriptionQuery,\n      _f = _e === void 0 ? {} : _e,\n      _g = _f.query,\n      subscriptionQueryQuery = _g === void 0 ? null : _g,\n      _h = _f.variables,\n      subscriptionQueryVariables = _h === void 0 ? {} : _h,\n      _j = options.deltaQuery,\n      _k = _j === void 0 ? {} : _j,\n      _l = _k.query,\n      deltaQueryQuery = _l === void 0 ? null : _l,\n      _m = _k.variables,\n      deltaQueryVariables = _m === void 0 ? {} : _m;\n\n  var baseQuery = baseQueryQuery ? {\n    query: graphql_1.print(baseQueryQuery),\n    variables: baseQueryVariables\n  } : {};\n  var subscriptionQuery = subscriptionQueryQuery ? {\n    query: graphql_1.print(subscriptionQueryQuery),\n    variables: subscriptionQueryVariables\n  } : {};\n  var deltaQuery = deltaQueryQuery ? {\n    query: graphql_1.print(deltaQueryQuery),\n    variables: deltaQueryVariables\n  } : {};\n  return utils_1.hash(JSON.stringify({\n    baseQuery: baseQuery,\n    subscriptionQuery: subscriptionQuery,\n    deltaQuery: deltaQuery\n  }));\n}; //#endregion\n//#region Redux\n\n\nvar effect = function effect(store, client, _effect, _action, _offlineCallback, offlineStatusChangeObservable) {\n  return __awaiter(_this, void 0, void 0, function () {\n    var options, _a, baseQuery, subscriptionQuery, deltaQuery, observer, _b, callback, upperBoundTimeMS, lastSyncTimestamp, baseLastSyncTimestamp, hash, itemInHash, networkStatusSubscription, subscription, baseQueryTimeoutId, subscriptionProcessor, unsubscribeAll, enqueueAgain, handle, STOP_CACHE_RECORDING, recorderCacheWrites, cacheProxy, error_2, _c, _d, _e, idsMap_1, cacheSnapshot, enquededMutations, subsControlLogger_1, baseRefreshIntervalInSeconds, skipBaseQuery, query, update_1, variables, result_1, _f, cacheSnapshot_1, data, query, update_2, variables, result_2, dataStore_1, enqueuedActionsFilter_1, baseQueryTimeout, error_1;\n\n    return __generator(this, function (_g) {\n      switch (_g.label) {\n        case 0:\n          options = _effect.options, _a = _effect.options, baseQuery = _a.baseQuery, subscriptionQuery = _a.subscriptionQuery, deltaQuery = _a.deltaQuery, observer = _effect.observer, _b = _effect.callback, callback = _b === void 0 ? function () {} : _b;\n\n          if (!observer || typeof observer.next !== 'function' || observer.closed) {\n            // If we don't have an observer, we complete this effect (this means the app was closed/opened and a completely \n            // new deltaSync will happen)\n            return [2\n            /*return*/\n            ];\n          }\n\n          upperBoundTimeMS = DEFAULT_UPPER_BOUND_TIME_MS;\n          lastSyncTimestamp = options.lastSyncTimestamp, baseLastSyncTimestamp = options.baseLastSyncTimestamp;\n          hash = exports.hashForOptions(options);\n          itemInHash = store.getState()[offline_cache_1.METADATA_KEY][exports.DELTASYNC_KEY].metadata[hash];\n\n          unsubscribeAll = function unsubscribeAll() {\n            logger('Unsubscribing');\n            if (networkStatusSubscription) networkStatusSubscription.unsubscribe();\n            if (subscription) subscription.unsubscribe();\n            if (baseQueryTimeoutId) clearTimeout(baseQueryTimeoutId);\n            if (subscriptionProcessor) subscriptionProcessor.close();\n          };\n\n          enqueueAgain = function enqueueAgain() {\n            unsubscribeAll();\n            logger('Re-queuing', {\n              baseLastSyncTimestamp: baseLastSyncTimestamp,\n              lastSyncTimestamp: lastSyncTimestamp\n            });\n            exports.boundEnqueueDeltaSync(store, __assign({}, options, {\n              lastSyncTimestamp: lastSyncTimestamp,\n              baseLastSyncTimestamp: baseLastSyncTimestamp\n            }), observer, callback);\n          };\n\n          if (typeof callback === 'function') {\n            handle = new apollo_link_1.Observable(function () {\n              return function () {\n                return unsubscribeAll();\n              };\n            }).subscribe({\n              next: function next() {}\n            });\n            callback(handle);\n          }\n\n          networkStatusSubscription = new apollo_link_1.Observable(function (obs) {\n            var handle = offlineStatusChangeObservable.subscribe({\n              next: function next(_a) {\n                var online = _a.online;\n\n                if (!online) {\n                  obs.next(null);\n                  obs.complete();\n                }\n              },\n              complete: function complete() {\n                return obs.complete();\n              }\n            });\n            return function () {\n              return handle.unsubscribe();\n            };\n          }).subscribe({\n            next: function next() {\n              enqueueAgain();\n            }\n          });\n          STOP_CACHE_RECORDING = typeof Symbol !== 'undefined' ? Symbol('stopCacheRecording') : '@@stopCacheRecording';\n          recorderCacheWrites = [];\n          cacheProxy = new Proxy(client.cache, {\n            get: function get(target, name, receiver) {\n              switch (name) {\n                case 'write':\n                  return function (options) {\n                    if (!receiver[STOP_CACHE_RECORDING]) {\n                      recorderCacheWrites.push(options);\n                    }\n\n                    return target[name](options);\n                  };\n              }\n\n              return target[name];\n            }\n          });\n          subscriptionProcessor = subscriptionMessagesProcessorCreator(cacheProxy, function (proxy, record) {\n            var update = options.subscriptionQuery.update;\n\n            if (typeof update === 'function') {\n              update(proxy, record);\n              client.queryManager.broadcastQueries();\n            }\n          });\n          _g.label = 1;\n\n        case 1:\n          _g.trys.push([1, 8,, 9]);\n\n          _c = store.getState(), _d = offline_cache_1.METADATA_KEY, _e = _c[_d], idsMap_1 = _e.idsMap, cacheSnapshot = _e.snapshot.cache, enquededMutations = _c.offline.outbox;\n          subsControlLogger_1 = logger.extend('subsc-control');\n          return [4\n          /*yield*/\n          , new Promise(function (resolve) {\n            var _a;\n\n            if (subscriptionQuery && subscriptionQuery.query) {\n              var query = subscriptionQuery.query,\n                  variables = subscriptionQuery.variables;\n              subscription = client.subscribe({\n                query: query,\n                variables: __assign({}, variables, (_a = {}, _a[retry_link_1.SKIP_RETRY_KEY] = true, _a[subscription_handshake_link_1.CONTROL_EVENTS_KEY] = true, _a))\n              }).filter(function (data) {\n                var _a = data.extensions,\n                    _b = _a === void 0 ? {} : _a,\n                    _c = _b.controlMsgType,\n                    controlMsgType = _c === void 0 ? undefined : _c,\n                    _d = _b.controlMsgInfo,\n                    controlMsgInfo = _d === void 0 ? undefined : _d;\n\n                var isControlMsg = typeof controlMsgType !== 'undefined';\n\n                if (controlMsgType) {\n                  subsControlLogger_1(controlMsgType, controlMsgInfo);\n\n                  if (controlMsgType === 'CONNECTED') {\n                    resolve();\n                  }\n                }\n\n                return !isControlMsg;\n              }).subscribe({\n                next: function next(data) {\n                  subscriptionProcessor.enqueue(data);\n                },\n                error: function error(err) {\n                  resolve();\n                  error_2 = err;\n                  unsubscribeAll();\n\n                  if (apollo_utilities_1.graphQLResultHasError(err) || err.graphQLErrors) {\n                    // send error to observable, unsubscribe all, do not enqueue\n                    observer.error(err);\n                    return;\n                  }\n\n                  enqueueAgain();\n                }\n              });\n            } else {\n              resolve();\n            }\n          })];\n\n        case 2:\n          _g.sent();\n\n          if (error_2) {\n            throw error_2;\n          }\n\n          baseRefreshIntervalInSeconds = (baseQuery || {\n            baseRefreshIntervalInSeconds: undefined\n          }).baseRefreshIntervalInSeconds;\n          upperBoundTimeMS = baseRefreshIntervalInSeconds ? baseRefreshIntervalInSeconds * 1000 : DEFAULT_UPPER_BOUND_TIME_MS;\n          skipBaseQuery = !(baseQuery && baseQuery.query) || (baseLastSyncTimestamp ? Date.now() - baseLastSyncTimestamp < upperBoundTimeMS : itemInHash.baseLastSyncTimestamp && Date.now() - itemInHash.baseLastSyncTimestamp < upperBoundTimeMS);\n          if (!(baseQuery && baseQuery.query)) return [3\n          /*break*/\n          , 5];\n          query = baseQuery.query, update_1 = baseQuery.update, variables = baseQuery.variables;\n          logger((skipBaseQuery ? 'Skipping' : 'Running') + \" base query\", {\n            baseLastSyncTimestamp: baseLastSyncTimestamp,\n            itemInHash: itemInHash\n          });\n          if (!!skipBaseQuery) return [3\n          /*break*/\n          , 4];\n          return [4\n          /*yield*/\n          , client.query({\n            fetchPolicy: 'no-cache',\n            query: query,\n            variables: variables\n          })];\n\n        case 3:\n          result_1 = _g.sent();\n          cacheProxy.writeQuery({\n            query: query,\n            data: result_1.data\n          });\n\n          if (typeof update_1 === 'function') {\n            apollo_utilities_1.tryFunctionOrLogError(function () {\n              update_1(cacheProxy, result_1);\n            });\n          }\n\n          baseLastSyncTimestamp = Date.now() - BUFFER_MILLISECONDS;\n          boundUpdateLastSync(store, {\n            hash: hash,\n            baseLastSyncTimestamp: baseLastSyncTimestamp\n          });\n          return [3\n          /*break*/\n          , 5];\n\n        case 4:\n          try {\n            if (enquededMutations.length === 1) {\n              offline_link_1.boundSaveSnapshot(store, client.cache);\n            }\n\n            _f = offline_cache_1.METADATA_KEY, cacheSnapshot_1 = store.getState()[_f].snapshot.cache;\n            data = cacheProxy.storeReader.readQueryFromStore({\n              store: apollo_cache_inmemory_1.defaultNormalizedCacheFactory(cacheSnapshot_1),\n              query: apollo_utilities_1.addTypenameToDocument(query),\n              variables: variables\n            });\n            cacheProxy.writeQuery({\n              query: query,\n              variables: variables,\n              data: data\n            });\n          } catch (error) {\n            logger('Error reading/writting baseQuery from store', error);\n          }\n\n          _g.label = 5;\n\n        case 5:\n          //#endregion\n          //#region Delta query\n          if (deltaQuery && deltaQuery.query && !skipBaseQuery) {\n            logger('Skipping deltaQuery');\n          }\n\n          if (!(deltaQuery && deltaQuery.query && skipBaseQuery)) return [3\n          /*break*/\n          , 7];\n          query = deltaQuery.query, update_2 = deltaQuery.update, variables = deltaQuery.variables;\n          logger('Running deltaQuery', {\n            lastSyncTimestamp: lastSyncTimestamp,\n            baseLastSyncTimestamp: baseLastSyncTimestamp\n          });\n          return [4\n          /*yield*/\n          , client.query({\n            fetchPolicy: 'no-cache',\n            query: query,\n            variables: __assign({}, variables, {\n              lastSync: Math.floor((lastSyncTimestamp || baseLastSyncTimestamp) / 1000) || 0\n            })\n          })];\n\n        case 6:\n          result_2 = _g.sent();\n\n          if (typeof update_2 === 'function') {\n            apollo_utilities_1.tryFunctionOrLogError(function () {\n              update_2(cacheProxy, result_2);\n            });\n          }\n\n          lastSyncTimestamp = Date.now() - BUFFER_MILLISECONDS;\n          boundUpdateLastSync(store, {\n            hash: hash,\n            lastSyncTimestamp: lastSyncTimestamp\n          });\n          _g.label = 7;\n\n        case 7:\n          //#endregion\n          if (error_2) {\n            throw error_2;\n          } // process subscription messages\n\n\n          subscriptionProcessor.ready();\n          cacheProxy[STOP_CACHE_RECORDING] = true;\n\n          if (enquededMutations.length === 1) {\n            offline_link_1.boundSaveSnapshot(store, client.cache);\n          } else {\n            // Restore from cache snapshot\n            client.cache.restore(cacheSnapshot);\n          }\n\n          recorderCacheWrites.forEach(client.cache.write.bind(client.cache));\n          offline_link_1.boundSaveSnapshot(store, client.cache);\n          client.initQueryManager();\n          dataStore_1 = client.queryManager.dataStore;\n          enqueuedActionsFilter_1 = [offline_link_1.offlineEffectConfig.enqueueAction];\n          enquededMutations.filter(function (_a) {\n            var type = _a.type;\n            return enqueuedActionsFilter_1.indexOf(type) > -1;\n          }).forEach(function (_a) {\n            var effect = _a.meta.offline.effect;\n\n            var _b = effect,\n                _c = _b.operation,\n                _d = _c === void 0 ? {} : _c,\n                _e = _d.variables,\n                variables = _e === void 0 ? {} : _e,\n                _f = _d.query,\n                document = _f === void 0 ? null : _f,\n                update = _b.update,\n                origOptimisticResponse = _b.optimisticResponse;\n\n            if (typeof update !== 'function') {\n              return;\n            }\n\n            var optimisticResponse = offline_link_1.replaceUsingMap(__assign({}, origOptimisticResponse), idsMap_1);\n            var result = {\n              data: optimisticResponse\n            };\n            dataStore_1.markMutationResult({\n              mutationId: null,\n              result: result,\n              document: document,\n              variables: variables,\n              updateQueries: {},\n              update: update\n            });\n          });\n          client.queryManager.broadcastQueries();\n\n          if (baseQuery && baseQuery.query) {\n            baseQueryTimeout = Math.max(upperBoundTimeMS - (Date.now() - baseLastSyncTimestamp), MIN_UPPER_BOUND_TIME_MS);\n            logger(\"Re-running in \" + baseQueryTimeout / 1000 / 60 + \" minutes\");\n            baseQueryTimeoutId = global.setTimeout(function () {\n              return enqueueAgain();\n            }, baseQueryTimeout);\n          }\n\n          return [3\n          /*break*/\n          , 9];\n\n        case 8:\n          error_1 = _g.sent();\n          unsubscribeAll();\n          throw error_1;\n\n        case 9:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n};\n\nvar discard = function discard(_callback, error, action, retries) {\n  var effect = action.meta.offline.effect;\n  var observer = effect.observer;\n\n  if (observer && observer.error && !observer.closed) {\n    observer.error(error);\n  }\n\n  return true;\n};\n\nvar reducer = function reducer() {\n  return function (state, action) {\n    var _a;\n\n    switch (action.type) {\n      case actions.UPDATE_LASTSYNC:\n        logger(action.type, action.payload);\n        return lastSyncReducer(state, action);\n\n      case actions.ENQUEUE:\n        logger(action.type, action.meta.offline.effect.options);\n        return metadataReducer(state, action);\n\n      default:\n        var newState = __assign({}, state, (_a = {}, _a[exports.DELTASYNC_KEY] = __assign({\n          metadata: {}\n        }, state.deltaSync), _a));\n\n        return newState;\n    }\n  };\n};\n\nvar lastSyncReducer = function lastSyncReducer(state, action) {\n  var _a, _b;\n\n  var _c = action.payload,\n      lastSyncTimestamp = _c.lastSyncTimestamp,\n      hash = _c.hash,\n      baseLastSyncTimestamp = _c.baseLastSyncTimestamp;\n\n  var _d = state[exports.DELTASYNC_KEY],\n      metadata = _d.metadata,\n      deltaSync = __rest(_d, [\"metadata\"]);\n\n  var _e = hash,\n      hashMetadata = metadata[_e],\n      otherHashes = __rest(metadata, [typeof _e === \"symbol\" ? _e : _e + \"\"]);\n\n  var newMetadata = {\n    baseLastSyncTimestamp: baseLastSyncTimestamp || hashMetadata.baseLastSyncTimestamp,\n    lastSyncTimestamp: lastSyncTimestamp\n  };\n\n  var newState = __assign({}, state, (_a = {}, _a[exports.DELTASYNC_KEY] = __assign({}, deltaSync, {\n    metadata: __assign({}, otherHashes, (_b = {}, _b[hash] = newMetadata, _b))\n  }), _a));\n\n  return newState;\n};\n\nvar metadataReducer = function metadataReducer(state, action) {\n  var _a, _b;\n\n  var effect = action.meta.offline.effect;\n  var options = effect.options;\n  var metadata = state[exports.DELTASYNC_KEY].metadata;\n  var hash = exports.hashForOptions(options);\n  var hashMetadata = metadata[hash];\n\n  var _c = hashMetadata || {},\n      _d = _c.lastSyncTimestamp,\n      lastSyncTimestamp = _d === void 0 ? options.lastSyncTimestamp : _d,\n      _e = _c.baseLastSyncTimestamp,\n      baseLastSyncTimestamp = _e === void 0 ? options.baseLastSyncTimestamp : _e;\n\n  var newMetadata = {\n    lastSyncTimestamp: lastSyncTimestamp,\n    baseLastSyncTimestamp: options.baseLastSyncTimestamp === null ? null : baseLastSyncTimestamp\n  };\n\n  var newState = __assign({}, state, (_a = {}, _a[exports.DELTASYNC_KEY] = {\n    metadata: __assign({}, metadata, (_b = {}, _b[hash] = newMetadata, _b))\n  }, _a));\n\n  return newState;\n};\n\nexports.boundEnqueueDeltaSync = function (store, options, observer, callback) {\n  var effect = {\n    options: options,\n    observer: observer,\n    callback: callback\n  };\n  store.dispatch({\n    type: exports.offlineEffectConfig.enqueueAction,\n    meta: {\n      offline: {\n        effect: effect\n      }\n    }\n  });\n};\n\nvar boundUpdateLastSync = function boundUpdateLastSync(store, _a) {\n  var hash = _a.hash,\n      lastSyncTimestamp = _a.lastSyncTimestamp,\n      baseLastSyncTimestamp = _a.baseLastSyncTimestamp;\n  var action = {\n    type: actions.UPDATE_LASTSYNC,\n    payload: {\n      hash: hash,\n      lastSyncTimestamp: lastSyncTimestamp,\n      baseLastSyncTimestamp: baseLastSyncTimestamp\n    }\n  };\n  store.dispatch(action);\n}; //#endregion\n//#region Builder\n\n\nexports.buildSync = function (typename, options, idField) {\n  if (idField === void 0) {\n    idField = 'id';\n  }\n\n  var baseQuery = options.baseQuery,\n      subscriptionQuery = options.subscriptionQuery,\n      deltaQuery = options.deltaQuery,\n      _a = options.cacheUpdates,\n      cacheUpdates = _a === void 0 ? function () {\n    return [];\n  } : _a;\n  var loggerHelper = logger.extend('helper');\n  var result = {\n    baseQuery: __assign({}, baseQuery, baseQuery && {\n      update: function update(cache, _a) {\n        var data = _a.data;\n        var opFieldName = utils_1.getOperationFieldName(baseQuery.query);\n        var _b = opFieldName,\n            result = data[_b];\n        writeCacheUpdates(loggerHelper, cache, result, cacheUpdates);\n      }\n    }),\n    subscriptionQuery: __assign({}, subscriptionQuery, subscriptionQuery && {\n      update: function update(cache, _a) {\n        var data = _a.data;\n        updateBaseWithDelta(loggerHelper, baseQuery, subscriptionQuery, cache, data, cacheUpdates, typename, idField);\n      }\n    }),\n    deltaQuery: __assign({}, deltaQuery, deltaQuery && {\n      update: function update(cache, _a) {\n        var data = _a.data;\n        updateBaseWithDelta(loggerHelper, baseQuery, deltaQuery, cache, data, cacheUpdates, typename, idField);\n      }\n    })\n  };\n  loggerHelper('buildSync options', result);\n  return result;\n};\n\nvar writeCacheUpdates = function writeCacheUpdates(logger, cache, result, cacheUpdates) {\n  if (cacheUpdates === void 0) {\n    cacheUpdates = function cacheUpdates() {\n      return [];\n    };\n  }\n\n  var cacheUpdatesLogger = logger.extend('cacheUpdates');\n  cacheUpdatesLogger('writeCacheUpdates');\n  result.forEach(function (item) {\n    return cacheUpdates(item).forEach(function (_a) {\n      var query = _a.query,\n          variables = _a.variables;\n\n      var _b;\n\n      var opFieldName = utils_1.getOperationFieldName(query);\n      var data = (_b = {}, _b[opFieldName] = item, _b);\n      cacheUpdatesLogger(\"Writing \" + opFieldName, {\n        variables: variables,\n        data: data\n      });\n      cache.writeQuery({\n        query: query,\n        variables: variables,\n        data: data\n      });\n    });\n  });\n};\n\nvar deltaRecordsProcessor = function deltaRecordsProcessor(logger, deltaOperationName, deltaRecords, baseResult, typename, idField) {\n  var opType = offline_1.getOpTypeFromOperationName(deltaOperationName);\n  logger({\n    deltaOperationName: deltaOperationName,\n    opType: opType,\n    deltaRecords: deltaRecords\n  });\n\n  if (!deltaRecords.length) {\n    return baseResult;\n  }\n\n  var result = baseResult.slice();\n  deltaRecords.forEach(function (deltaRecord) {\n    var incomingRecord = __assign({}, deltaRecord, {\n      __typename: typename\n    });\n\n    var isRemove = opType === offline_1.CacheOperationTypes.REMOVE || incomingRecord.aws_ds === 'DELETE';\n    var updater = offline_1.getUpdater(opType === offline_1.CacheOperationTypes.AUTO && !isRemove ? offline_1.CacheOperationTypes.ADD : isRemove ? offline_1.CacheOperationTypes.REMOVE : opType, idField);\n    logger({\n      incomingRecord: incomingRecord,\n      isRemove: isRemove\n    });\n    result = updater(result.slice(), incomingRecord);\n  });\n  return result;\n};\n\nvar updateBaseWithDelta = function updateBaseWithDelta(logger, baseQuery, otherQuery, cache, data, cacheUpdates, typename, idField) {\n  if (cacheUpdates === void 0) {\n    cacheUpdates = function cacheUpdates() {\n      return [];\n    };\n  }\n\n  if (idField === void 0) {\n    idField = 'id';\n  }\n\n  var _a;\n\n  var updateLogger = logger.extend('update');\n  var opDefinition = apollo_utilities_1.getMainDefinition(otherQuery.query);\n  var _b = opDefinition.selectionSet.selections[0],\n      opName = _b.name.value,\n      opAliasNode = _b.alias;\n  var _c = (opAliasNode || {}).value,\n      opAlias = _c === void 0 ? null : _c;\n  var _d = opDefinition,\n      kind = _d.kind,\n      graphqlOperation = _d.operation;\n  var isSubscription = kind === 'OperationDefinition' && graphqlOperation === 'subscription';\n  var deltaOperationName = (isSubscription ? Object.keys(data) : [opAlias || opName])[0];\n  var _e = deltaOperationName,\n      records = data[_e];\n  var deltaRecords = [].concat(records);\n\n  if (!baseQuery || !baseQuery.query) {\n    updateLogger('No baseQuery provided');\n  } else {\n    var query = baseQuery.query,\n        variables = baseQuery.variables;\n    var operationName = utils_1.getOperationFieldName(query);\n\n    var _f = operationName,\n        baseResult = cache.readQuery({\n      query: query,\n      variables: variables\n    })[_f];\n\n    if (!Array.isArray(baseResult)) {\n      throw new Error('Result of baseQuery is not an array');\n    }\n\n    var result = deltaRecordsProcessor(updateLogger, deltaOperationName, deltaRecords, baseResult, typename, idField);\n\n    if (result !== baseResult) {\n      cache.writeQuery({\n        query: query,\n        data: (_a = {}, _a[operationName] = result, _a)\n      });\n    }\n  }\n\n  writeCacheUpdates(updateLogger, cache, deltaRecords, cacheUpdates);\n}; //#endregion\n\n\nexports.offlineEffectConfig = {\n  enqueueAction: actions.ENQUEUE,\n  effect: effect,\n  discard: discard,\n  reducer: reducer\n};","map":null,"metadata":{},"sourceType":"script"}