{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) {\n      if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n  }\n\n  return t;\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { ApolloLink, Observable } from 'apollo-link';\nimport { print } from 'graphql/language/printer';\n\nvar throwServerError = function throwServerError(response, result, message) {\n  var error = new Error(message);\n  error.response = response;\n  error.statusCode = response.status;\n  error.result = result;\n  throw error;\n};\n\nvar parseAndCheckResponse = function parseAndCheckResponse(request) {\n  return function (response) {\n    return response.text().then(function (bodyText) {\n      try {\n        return JSON.parse(bodyText);\n      } catch (err) {\n        var parseError = err;\n        parseError.response = response;\n        parseError.statusCode = response.status;\n        parseError.bodyText = bodyText;\n        return Promise.reject(parseError);\n      }\n    }).then(function (result) {\n      if (response.status >= 300) {\n        throwServerError(response, result, \"Response not successful: Received status code \" + response.status);\n      }\n\n      if (!result.hasOwnProperty('data') && !result.hasOwnProperty('errors')) {\n        throwServerError(response, result, \"Server response was missing for query '\" + request.operationName + \"'.\");\n      }\n\n      return result;\n    });\n  };\n};\n\nvar checkFetcher = function checkFetcher(fetcher) {\n  if (fetcher.use) {\n    throw new Error(\"\\n      It looks like you're using apollo-fetch! Apollo Link now uses native fetch\\n      implementation, so apollo-fetch is not needed. If you want to use your existing\\n      apollo-fetch middleware, please check this guide to upgrade:\\n        https://github.com/apollographql/apollo-link/blob/master/docs/implementation.md\\n    \");\n  }\n};\n\nvar warnIfNoFetch = function warnIfNoFetch(fetcher) {\n  if (!fetcher && typeof fetch === 'undefined') {\n    var library = 'unfetch';\n    if (typeof window === 'undefined') library = 'node-fetch';\n    throw new Error(\"fetch is not found globally and no fetcher passed, to fix pass a fetch for\\n      your environment like https://www.npmjs.com/package/\" + library + \".\\n\\n      For example:\\n        import fetch from '\" + library + \"';\\n        import { createHttpLink } from 'apollo-link-http';\\n\\n        const link = createHttpLink({ uri: '/graphql', fetch: fetch });\\n      \");\n  }\n};\n\nvar createSignalIfSupported = function createSignalIfSupported() {\n  if (typeof AbortController === 'undefined') return {\n    controller: false,\n    signal: false\n  };\n  var controller = new AbortController();\n  var signal = controller.signal;\n  return {\n    controller: controller,\n    signal: signal\n  };\n};\n\nvar defaultHttpOptions = {\n  includeQuery: true,\n  includeExtensions: false\n};\nexport var createHttpLink = function createHttpLink(linkOptions) {\n  if (linkOptions === void 0) {\n    linkOptions = {};\n  }\n\n  var uri = linkOptions.uri,\n      fetcher = linkOptions.fetch,\n      includeExtensions = linkOptions.includeExtensions,\n      requestOptions = __rest(linkOptions, [\"uri\", \"fetch\", \"includeExtensions\"]);\n\n  warnIfNoFetch(fetcher);\n  if (fetcher) checkFetcher(fetcher);\n  if (!fetcher) fetcher = fetch;\n  if (!uri) uri = '/graphql';\n  return new ApolloLink(function (operation) {\n    return new Observable(function (observer) {\n      var _a = operation.getContext(),\n          headers = _a.headers,\n          credentials = _a.credentials,\n          _b = _a.fetchOptions,\n          fetchOptions = _b === void 0 ? {} : _b,\n          contextURI = _a.uri,\n          _c = _a.http,\n          httpOptions = _c === void 0 ? {} : _c;\n\n      var operationName = operation.operationName,\n          extensions = operation.extensions,\n          variables = operation.variables,\n          query = operation.query;\n\n      var http = __assign({}, defaultHttpOptions, httpOptions);\n\n      var body = {\n        operationName: operationName,\n        variables: variables\n      };\n      if (includeExtensions || http.includeExtensions) body.extensions = extensions;\n      if (http.includeQuery) body.query = print(query);\n      var serializedBody;\n\n      try {\n        serializedBody = JSON.stringify(body);\n      } catch (e) {\n        var parseError = new Error(\"Network request failed. Payload is not serializable: \" + e.message);\n        parseError.parseError = e;\n        throw parseError;\n      }\n\n      var options = fetchOptions;\n      if (requestOptions.fetchOptions) options = __assign({}, requestOptions.fetchOptions, options);\n\n      var fetcherOptions = __assign({\n        method: 'POST'\n      }, options, {\n        headers: {\n          accept: '*/*',\n          'content-type': 'application/json'\n        },\n        body: serializedBody\n      });\n\n      if (requestOptions.credentials) fetcherOptions.credentials = requestOptions.credentials;\n      if (credentials) fetcherOptions.credentials = credentials;\n      if (requestOptions.headers) fetcherOptions.headers = __assign({}, fetcherOptions.headers, requestOptions.headers);\n      if (headers) fetcherOptions.headers = __assign({}, fetcherOptions.headers, headers);\n\n      var _d = createSignalIfSupported(),\n          controller = _d.controller,\n          signal = _d.signal;\n\n      if (controller) fetcherOptions.signal = signal;\n      fetcher(contextURI || uri, fetcherOptions).then(function (response) {\n        operation.setContext({\n          response: response\n        });\n        return response;\n      }).then(parseAndCheckResponse(operation)).then(function (result) {\n        observer.next(result);\n        observer.complete();\n        return result;\n      }).catch(function (err) {\n        if (err.name === 'AbortError') return;\n        observer.error(err);\n      });\n      return function () {\n        if (controller) controller.abort();\n      };\n    });\n  });\n};\n\nvar HttpLink = function (_super) {\n  __extends(HttpLink, _super);\n\n  function HttpLink(opts) {\n    return _super.call(this, createHttpLink(opts).request) || this;\n  }\n\n  return HttpLink;\n}(ApolloLink);\n\nexport { HttpLink };","map":null,"metadata":{},"sourceType":"module"}